/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Builds a Ghidra Extension for a given Ghidra installation.
//
// An absolute path to the Ghidra installation directory must be supplied either by setting the 
// GHIDRA_INSTALL_DIR environment variable or Gradle project property:
//
//     > export GHIDRA_INSTALL_DIR=<Absolute path to Ghidra> 
//     > gradle
//
//         or
//
//     > gradle -PGHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//
// Gradle should be invoked from the directory of the project to build.  Please see the
// application.gradle.version property in <GHIDRA_INSTALL_DIR>/Ghidra/application.properties
// for the correction version of Gradle to use for the Ghidra installation you specify.

plugins  {
  id "com.google.protobuf" version "0.9.2"
  id 'scala'
  id 'java'
  id "com.diffplug.spotless" version "6.18.0"
}

//----------------------START "DO NOT MODIFY" SECTION------------------------------
def ghidraInstallDir

if (System.env.GHIDRA_INSTALL_DIR) {
  ghidraInstallDir = System.env.GHIDRA_INSTALL_DIR
}
else if (project.hasProperty("GHIDRA_INSTALL_DIR")) {
  ghidraInstallDir = project.getProperty("GHIDRA_INSTALL_DIR")
}

if (ghidraInstallDir) {
  apply from: new File(ghidraInstallDir).getCanonicalPath() + "/support/buildExtension.gradle"
}
else {
  throw new GradleException("GHIDRA_INSTALL_DIR is not defined!")
}
//----------------------END "DO NOT MODIFY" SECTION-------------------------------

ext {
    scalapbVersion = '0.11.13'
    grpcVersion = '1.53.0'
    protobufVersion = '3.22.2'
}

repositories {
  // Declare dependency repositories here.  This is not needed if dependencies are manually 
  // dropped into the lib/ directory.
  // See https://docs.gradle.org/current/userguide/declaring_repositories.html for more info.
  // Ex: mavenCentral()
  mavenCentral()
}

dependencies {
  // Any external dependencies added here will automatically be copied to the lib/ directory when
  // this extension is built.  
  implementation 'org.scala-lang:scala3-library_3:3.1.3'
  implementation "com.thesamet.scalapb:scalapb-json4s_3:0.12.1"
  implementation "com.thesamet.scalapb:scalapb-runtime_3:${scalapbVersion}"
  implementation "io.grpc:grpc-stub:${grpcVersion}"
  implementation "io.grpc:grpc-protobuf:${grpcVersion}"
  implementation "com.google.protobuf:protobuf-java-util:${protobufVersion}"
  if (JavaVersion.current().isJava9Compatible()) {
      // Workaround for @javax.annotation.Generated
      // see: https://github.com/grpc/grpc-java/issues/3633
      implementation 'javax.annotation:javax.annotation-api:1.3.2'
  }
  implementation 'org.scalaz:scalaz-core_3:7.3.7'
  implementation 'org.scala-graph:graph-core_2.13:1.13.5'

  runtimeOnly "io.grpc:grpc-netty-shaded:${grpcVersion}"

  testImplementation 'junit:junit:4.13.2'

  testRuntimeOnly files("lib")
}


// The following installation helpers were copied from
// https://github.com/cmu-sei/kaiju/blob/c00a351aa4332e8b6e2be94f6fe52418f8946b11/build.gradle
task uninstallPreviousIRENEGhidra {
    description = "Removes a previous IRENEGhidra installation, or notifies user of previous installation"

    doFirst {

        // check if a previous IRENEGhidra installation exists
        if (file(ghidraInstallDir + '/Ghidra/Extensions/' + 'irene-ghidra/').exists()) {

            // automatically remove past install if user specifies
            if (project.hasProperty('IRENEGHIDRA_AUTO_REMOVE')) {
                def ooDir = new File(ghidraInstallDir + '/Ghidra/Extensions/' + 'irene-ghidra/')
                ooDir.deleteDir()
                logger.quiet("SUCCESS! Previous standalone IRENEGhidra installation was removed automatically by gradle.")
            } else {
                throw new GradleException("FATAL ERROR! A previous installation of IRENEGhidra was detected. It is recommended that you either manually remove this installation before re-installing IRENEGhidra, or re-run this gradle installation script with the -PIRENEGHIDRA_AUTO_REMOVE option.")
            }
        }
    }

    outputs.upToDateWhen { false } // ensures never cached, always runs if user enables
}
buildHelp.dependsOn uninstallPreviousIRENEGhidra

task copyZip(type: Copy) {

    group = "Installation"
    description = "Copies zip contents into special Extensions directory so user may enable or disable easily with reinstalling from gradle each time."

    from "${buildExtension.destinationDirectory.get()}/${buildExtension.archiveBaseName.get()}.${buildExtension.archiveExtension.get()}"
    into ghidraInstallDir + '/Extensions/Ghidra'

    dependsOn buildExtension
}

task installZip(type: Exec) {

    group = "Installation"
    description = "Installs the zip package in installed Ghidra's default extension directory"

    workingDir ghidraInstallDir + '/Ghidra/Extensions'
    commandLine 'unzip', '-o', "${buildExtension.destinationDirectory.get()}/${buildExtension.archiveBaseName.get()}.${buildExtension.archiveExtension.get()}"

    dependsOn copyZip
}

task install() {
    dependsOn installZip

    group = "Installation"
    description = "Alternate name for installZip task"

    doLast {
        // Empty action list
        logger.quiet("Installed Trail of Bits IRENEGhidra from zip!")
    }
}

protobuf {
  protoc {
    artifact = "com.google.protobuf:protoc:${protobufVersion}"
  }
  plugins {
    scalapb {
        artifact = (org.gradle.nativeplatform.platform.internal.DefaultNativePlatform.getCurrentOperatingSystem().isWindows()) ?
            "com.thesamet.scalapb:protoc-gen-scala:${scalapbVersion}:windows@bat" :
            "com.thesamet.scalapb:protoc-gen-scala:${scalapbVersion}:unix@sh"
    }
    grpc {
        artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}"
    }
  }

  generateProtoTasks {
    all().each { task ->
      task.addIncludeDir(files('../vendor'))
      task.addSourceDirs(files('../vendor/anvill/data_specifications'))
      task.plugins {
          scalapb {
            // add any ScalaPB generator options here. See: https://scalapb.github.io/scalapbc.html#passing-generator-parameters
            // option 'flat_package'
            // option 'grpc'
            option 'java_conversions'
          }
          grpc {}
      }
    }
  }
}

// Required for protobuf dependency management. Not sure why this isn't
// captured in 'generateProtoTasks' section
tasks.configureEach { task ->
    if (task.name == 'extractIncludeProto' ||
            task.name == 'extractIncludeTestProto' ||
            task.name == 'extractProto' ||
            task.name == 'extractTestProto') {
        task.dependsOn copyDependencies
    }
}


test {
    useJUnit()
    // set JVM arguments for the test JVM(s)
    // Copied from some of Ghidra's properties in
    // 'gradle/javaTestProject.gradle' and
    // 'Ghidra/Test/IntegrationTest/build.gradle'
    jvmArgs '--add-exports=java.desktop/sun.awt=ALL-UNNAMED' // Required for Java 17 compatibility
}


spotless {
  java {
    target 'src/*/java/**/*.java', 'ghidra_scripts/*.java'
    importOrder()
    removeUnusedImports()
    googleJavaFormat()
    formatAnnotations() 
  }

  scala {
    target 'src/*/scala/**/*.scala'
    scalafmt('3.5.3').configFile('.scalafmt.conf')
  }
}

sourceSets {
  main {
    scala {
        srcDirs "${protobuf.generatedFilesBaseDir}/main/scalapb"
        srcDirs 'ghidra_scripts'
        srcDirs 'src/main/scala'
    }

    java {
        srcDirs "${protobuf.generatedFilesBaseDir}/main/grpc"
        srcDirs "${protobuf.generatedFilesBaseDir}/main/java"
        srcDirs 'src/main/java'
    }

    proto {
        // In addition to the default 'src/main/proto'
        // We only include Codegen proto because gradle will automatically
        // follow imports to build the other protobufs
        srcDirs '../bin/Codegen'
        // In addition to the default '**/*.proto' (use with caution).
        // Using an extension other than 'proto' is NOT recommended,
        // because when proto files are published along with class files, we can
        // only tell the type of a file from its extension.
        include '*.proto'
    }
  }
}
// End copy
